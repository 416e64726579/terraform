// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

syntax = "proto3";
package terraform1;

import "google/protobuf/any.proto";

service Setup {
    // Clients must call Handshake before any other function of any other
    // service, to complete the capability negotiation step that may
    // then affect the behaviors of subsequent operations.
    //
    // This function can be called only once per RPC server.
    rpc Handshake(Handshake.Request) returns (Handshake.Response);
}

message Handshake {
    message Request {
        ClientCapabilities capabilities = 1;
    }
    message Response {
        ServerCapabilities capabilities = 2;
    }
}

service Dependencies {
    // Opens a source bundle that was already extracted into the filesystem
    // somewhere, returning an opaque source bundle handle that can be used for
    // subsequent operations.
    rpc OpenSourceBundle(OpenSourceBundle.Request) returns (OpenSourceBundle.Response);

    // Closes a previously-opened source bundle, invalidating the given handle
    // and therefore making it safe to delete or modify the bundle directory
    // on disk.
    rpc CloseSourceBundle(CloseSourceBundle.Request) returns (CloseSourceBundle.Response);
}

message OpenSourceBundle {
    message Request {
        string local_path = 1;
    }
    message Response {
        int64 source_bundle_handle = 1;
    }
}

message CloseSourceBundle {
    message Request {
        int64 source_bundle_handle = 1;
    }
    message Response {
    }
}

// The capabilities that the client wishes to advertise to the server during
// handshake.
message ClientCapabilities {
    // There are not yet any negotiatable capabilities.
}

// The capabilities that the server wishes to advertise to the client during
// handshake. Fields in this message can also be used to acknowledge and
// confirm support for client capabilities advertised in ClientCapabilities,
// in situations where the client must vary its behavior based on the server's
// level of support.
message ServerCapabilities {
    // There are not yet any negotiatable capabilities.
}

service Stacks {
    // Load and perform initial static validation of a stack configuration
    // in a previously-opened source bundle. If successful, returns a
    // stack configuration handle that can be used with other operations.
    rpc OpenStackConfiguration(OpenStackConfiguration.Request)
        returns (OpenStackConfiguration.Response);
    // Close a previously-opened stack configuration using its handle.
    rpc CloseStackConfiguration(CloseStackConfiguration.Request)
        returns (CloseStackConfiguration.Response);
    // Analyze a stack configuration to find all of the providers that it
    // depends on.
    rpc FindStackConfigurationProviders(FindStackConfigurationProviders.Request) 
        returns (FindStackConfigurationProviders.Response);
    // Analyze a stack configuration to find all of the components it declares.
    // This is static analysis only, so it cannot produce dynamic information
    // such as the number of instances of each component.
    rpc FindStackConfigurationComponents(FindStackConfigurationComponents.Request)
        returns (FindStackConfigurationComponents.Response);
    // Calculate a desired state from the given configuration and compare it
    // with the current state to propose a set of changes to converge the
    // current state with the desired state, at least in part.
    rpc PlanStackChanges(PlanStackChanges.Request)
        returns (stream PlanStackChanges.Event);
}

message OpenStackConfiguration {
    message Request {
        int64 source_bundle_handle = 1;
        SourceAddress source_address = 2;
    }
    message Response {
        int64 stack_config_handle = 1;
        repeated Diagnostic diagnostics = 2;
    }
}

message CloseStackConfiguration {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
    }
}

message FindStackConfigurationComponents {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
        StackConfig config = 1;
    }

    enum Instances {
        SINGLE = 0;
        COUNT = 1;
        FOR_EACH = 2;
    }
    message StackConfig {
        map<string, Component> components = 1;
        map<string, EmbeddedStack> embedded_stacks = 2;
    }
    message EmbeddedStack {
        string source_addr = 1;
        Instances instances = 2;
        StackConfig config = 3;
    }
    message Component {
        string source_addr = 1;
        Instances instances = 2;
    }
}

message FindStackConfigurationProviders {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
        // TODO
    }
}

message PlanStackChanges {
    message Request {
        PlanMode plan_mode = 1;
        int64 stack_config_handle = 2;
        map<string, google.protobuf.Any> previous_state = 3;
        // TODO: Various other planning options and dependencies such as a
        // provider cache handle.
    }
    message Event {
        oneof event {
            PlannedChange planned_change = 1;
            Diagnostic diagnostic = 2;
            // TODO
        }
    }
}

// Represents dynamically-typed data from within the Terraform language.
// Typically only one of the available serialization formats will be populated,
// depending on what serializations are appropriate for a particular context
// and what capabilities the client and the server negotiated during Handshake.
message DynamicValue {
    bytes msgpack = 1; // The default serialization format
    repeated AttributePath sensitive = 2; // Paths to any sensitive-marked values.
}

// Represents a change of some object from one  dynamic value to another.
message DynamicValueChange {
    DynamicValue old = 1;
    DynamicValue new = 2;
}

message AttributePath {
    message Step {
        oneof selector {
            // Set "attribute_name" to represent looking up an attribute
            // in the current object value.
            string attribute_name = 1;
            // Set "element_key_*" to represent looking up an element in
            // an indexable collection type.
            string element_key_string = 2;
            int64 element_key_int = 3;
        }
    }
    repeated Step steps = 1;
}

// Represents the address of a specific resource instance inside a specific
// component instance within the containing stack.
message ResourceInstanceInStackAddr {
    // Unique address of the component instance that this resource instance
    // belongs to. This is comparable with
    string component_instance_addr = 1;
    // Unique address of the resource instance within the given component
    // instance. Each component instance has a separate namespace of
    // resource instance addresses, so callers must take both fields together
    // to produce a key that's unique throughout the entire plan.
    string resource_instance_addr = 2;
}

// A source address in the same form as it would appear in a Terraform
// configuration: a source string combined with an optional version constraint
// string, where the latter is valid only for registry module addresses.
//
// This is not used for "final" source addresses that have already been reduced
// to an exact version selection. For those we just directly encode the string
// representation of the final address, including a version number if necessary.
message SourceAddress {
    string source = 1;
    string versions = 2;
}

enum PlanMode {
    NORMAL = 0;
    REFRESH_ONLY = 1;
    DESTROY = 2;
}

enum ChangeType {
    NOOP = 0;
    READ = 1;
    CREATE = 2;
    UPDATE = 3;
    DELETE = 4;
}

// Describes one item in a stack plan. The overall plan is the concatentation
// of all messages of this type emitted as events during the plan; splitting
// this information over multiple messages just allows the individual events
// to double as progress notifications for an interactive UI.
message PlannedChange {
    // Terraform Core's internal representation(s) of this change. Callers
    // must provide the messages in this field, if any, verbatim to the
    // ApplyStackChanges RPC in order to apply this change, and must not
    // attempt to decode or analyze the contents because they are subject
    // to change in future versions of Terraform Core.
    //
    // This might be unpopulated if this message represents only information
    // for the caller and Terraform Core doesn't actually need to recall this
    // information during the apply step. Callers must append each raw item
    // to the raw plan in the order specified, and provide them all together
    // in the same order to ApplyStackChanges.
    repeated google.protobuf.Any raw = 1;

    // Caller-facing description of this change, to use for presenting
    // information to end-users in the UI and for other subsystems such as
    // imposing policy rules on the resulting plan.
    //
    // If none of these fields are populated in a given event then the
    // raw messages in "raw" represent private information that has no
    // external-facing equivalent. Callers must still retain the raw messages
    // to provide to a subsequent ApplyStackChanges RPC.
    //
    // DO NOT attempt to use this to surgically filter particular changes
    // from a larger plan. Although external descriptions often match with
    // the raw representations in field "raw", that is not guaranteed and
    // Terraform Core assumes that it will always be provided with the full
    // set of raw messages -- in the same order they were emitted -- during
    // the apply step. For example, some raw messages might omit information
    // that is implied by earlier raw messages and would therefore be
    // incomplete if isolated.
    oneof description {
        ComponentInstance component_instance_planned = 2;
        ResourceInstance resource_instance_drifted = 3;
        ResourceInstance resource_instance_planned = 4;
        OutputValue output_value_planned = 5;
    }

    // A set of provider selections that will be needed to apply this
    // change, which the caller should remember and use to populate the
    // provider cache during the apply step.
    // TODO: Fill out all of the provider-related functionality in here.
    //repeated ProviderSelection providers = 6;

    // Reports the existence of a particular instance of a component,
    // once Terraform has resolved arguments such as "for_each" that
    // might make the set of instances dynamic.
    message ComponentInstance {
        // The address of the static component that this is an instance of.
        string component_addr = 1;
        // The address of the instance that's being announced. For
        // multi-instance components this could have any combination of
        // instance keys on the component itself or instance keys on any
        // of the containing embedded stacks.
        string component_instance_addr = 2;
    }
    message ResourceInstance {
        ResourceInstanceInStackAddr addr = 1;
        repeated ChangeType actions = 2;
        DynamicValueChange values = 3;
        Moved moved = 4;
        Imported imported = 5;
        // TODO: Everything else we need for feature-parity with the
        // existing JSON plan export format.

        message Moved {
            ResourceInstanceInStackAddr prev_addr = 1;
        }
        message Imported {
            string import_id = 1;
        }
    }
    // Note: this is only for output values from the topmost
    // stack configuration, because all other output values are 
    // internal to the configuration and not part of its public API.
    message OutputValue {
        string name = 1;
        repeated ChangeType actions = 2;
        DynamicValueChange values = 3;
    }
}

message Diagnostic {
    enum Severity {
        INVALID = 0;
        ERROR = 1;
        WARNING = 2;
    }
    Severity severity = 1;
    string summary = 2;
    string detail = 3;
    SourceRange subject = 4;
    SourceRange context = 5;
}

message SourceRange {
    string source_addr = 1;
    SourcePos start = 2;
    SourcePos end = 3;
}

message SourcePos {
    int64 byte = 1;
    int64 line = 2;
    int64 column = 3;
}
