// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

syntax = "proto3";
package terraform1;

import "google/protobuf/any.proto";

service Setup {
    // Clients must call Handshake before any other function of any other
    // service, to complete the capability negotiation step that may
    // then affect the behaviors of subsequent operations.
    //
    // This function can be called only once per RPC server.
    rpc Handshake(Handshake.Request) returns (Handshake.Response);
}

message Handshake {
    message Request {
        ClientCapabilities capabilities = 1;
    }
    message Response {
        ServerCapabilities capabilities = 2;
    }
}

// The capabilities that the client wishes to advertise to the server during
// handshake.
message ClientCapabilities {
    // There are not yet any negotiatable capabilities.
}

// The capabilities that the server wishes to advertise to the client during
// handshake. Fields in this message can also be used to acknowledge and
// confirm support for client capabilities advertised in ClientCapabilities,
// in situations where the client must vary its behavior based on the server's
// level of support.
message ServerCapabilities {
    // There are not yet any negotiatable capabilities.
}

service Dependencies {
    // Opens a source bundle that was already extracted into the filesystem
    // somewhere, returning an opaque source bundle handle that can be used for
    // subsequent operations.
    rpc OpenSourceBundle(OpenSourceBundle.Request) returns (OpenSourceBundle.Response);

    // Closes a previously-opened source bundle, invalidating the given handle
    // and therefore making it safe to delete or modify the bundle directory
    // on disk.
    rpc CloseSourceBundle(CloseSourceBundle.Request) returns (CloseSourceBundle.Response);

    // Reads and parses an existing dependency lock file from the filesystem,
    // returning a dependency locks handle.
    //
    // This function parses a user-provided source file, and so invalid content
    // in that file is treated as diagnostics in a successful response rather
    // than as an RPC error. Callers must check whether the dependency locks
    // handle in the response is set (non-zero) before using it, and treat
    // an unset handle as indicating a user error which is described in the
    // accompanying diagnostics. Diagnostics can also be returned along with
    // a valid handle, e.g. if there are non-blocking warning diagnostics.
    rpc OpenDependencyLockFile(OpenDependencyLockFile.Request) returns (OpenDependencyLockFile.Response);

    rpc CloseDependencyLocks(CloseDependencyLocks.Request) returns (CloseDependencyLocks.Response);

    // Returns information about the provider version selections in a
    // dependency locks object.
    rpc GetLockedProviderDependencies(GetLockedProviderDependencies.Request) returns (GetLockedProviderDependencies.Response);

    // Populates a new provider plugin cache directory in the local filesystem
    // based on the provider version selections in a given dependency locks
    // object.
    //
    // This particular RPC can only install already-selected provider packages
    // recorded in a dependency locks object; it does not support "upgrading"
    // provider selections to newer versions as a CLI user would do with
    // "terraform init -upgrade", because there would be no way to then
    // commit the updated locks to disk as a lock file.
    rpc BuildProviderPluginCache(BuildProviderPluginCache.Request) returns (stream BuildProviderPluginCache.Event);

    // Opens an existing local filesystem directory as a provider plugin cache
    // directory, returning a plugin cache handle that can be used with other
    // RPC operations.
    rpc OpenProviderPluginCache(OpenProviderPluginCache.Request) returns (OpenProviderPluginCache.Response);

    rpc CloseProviderPluginCache(CloseProviderPluginCache.Request) returns (CloseProviderPluginCache.Response);

    // Returns information about the specific provider packages that are
    // available in the given provider plugin cache.
    rpc GetCachedProviders(GetCachedProviders.Request) returns (GetCachedProviders.Response);

    // Returns a description of the schema for a particular provider in a
    // given provider plugin cache, or of a particular built-in provider
    // known to this version of Terraform Core.
    //
    // WARNING: This operation requires executing the selected provider plugin,
    // which therefore allows it to run arbitrary code as a child process of
    // this Terraform Core server, with access to all of the same resources.
    // This should typically be used only with providers explicitly selected
    // in a dependency lock file, so users can control what external code
    // has the potential to run in a context that probably has access to
    // private source code and other sensitive information.
    rpc GetProviderSchema(GetProviderSchema.Request) returns (GetProviderSchema.Response);
}

message OpenSourceBundle {
    message Request {
        string local_path = 1;
    }
    message Response {
        int64 source_bundle_handle = 1;
    }
}

message CloseSourceBundle {
    message Request {
        int64 source_bundle_handle = 1;
    }
    message Response {
    }
}

message OpenDependencyLockFile {
    message Request {
        int64 source_bundle_handle = 1;
        SourceAddress source_address = 2;
    }
    message Response {
        int64 dependency_locks_handle = 1;
        repeated Diagnostic diagnostics = 2;
    }
}

message CloseDependencyLocks {
    message Request {
        int64 dependency_locks_handle = 1;
    }
    message Response {
    }
}

message GetLockedProviderDependencies {
    message Request {
        int64 dependency_locks_handle = 1;
    }
    message Response {
        repeated ProviderPackage selected_providers = 1;
    }
}

message BuildProviderPluginCache {
    message Request {
        string cache_dir = 1;
        int64 dependency_locks_handle = 2;
        repeated InstallMethod installation_methods = 3;

        // If set, this populates the cache with plugins for a different
        // platform than the one the Terraform Core RPC server is running on.
        // If unset (empty) then the cache will be populated with packages
        // for the same platform as Terraform Core was built for, if available.
        //
        // If this is set to a different platform than the Terraform Core RPC
        // server's then the generated cache directory will appear empty to
        // other operations on this server.
        string override_platform = 4;

        message InstallMethod {
            oneof source {
                bool direct = 1;
                string local_mirror_dir = 2;
                string network_mirror_url = 3;
            }
            repeated string include = 4;
            repeated string exclude = 5;
        }
    }
    message Event {
        oneof event {
            Pending pending = 1;
            ProviderVersion already_installed = 2;

            ProviderVersion built_in = 3;
            ProviderConstraints query_begin = 4;
            ProviderVersion query_success = 5;
            ProviderWarnings query_warnings = 6;

            FetchBegin fetch_begin = 7;
            FetchComplete fetch_complete = 8;

            Diagnostic diagnostic = 9;
        }

        message Pending {
            repeated ProviderConstraints expected = 1;
        }
        message ProviderConstraints {
            string source_addr = 1;
            string versions = 2;
        }
        message ProviderVersion {
            string source_addr = 1;
            string version = 2;
        }
        message ProviderWarnings {
            string source_addr = 1;
            repeated string warnings = 2;
        }
        message FetchBegin {
            ProviderVersion provider_version = 1;
            string location = 2;
        }
        message FetchComplete {
            ProviderVersion provider_version = 1;
            AuthResult auth_result = 2;

            // If auth_result is one of the "_SIGNED" variants then this
            // might contain a UI-oriented identifier for the key that
            // signed the package. The exact format of this string is not
            // guaranteed; do not attempt to parse it or make automated
            // decisions based on it.
            string key_id_for_display = 3;

            enum AuthResult {
                UNKNOWN = 0;
                VERIFIED_CHECKSUM = 1;
                OFFICIAL_SIGNED = 2;
                PARTNER_SIGNED = 3;
                SELF_SIGNED = 4;
            }
        }
    }
}

message OpenProviderPluginCache {
    message Request {
        string cache_dir = 1;

        // As with the field of the same name in BuildProviderPluginCache.Request.
        //
        // If this is set to anything other than this RPC server's native
        // platform then any operations that require executing the provider
        // plugin are likely to fail due to executable format errors or
        // similar. However, it's valid to use the returned handle with
        // GetCachedProviders, since it only analyzes the cache metadata
        // and doesn't actually run the plugins inside.
        string override_platform = 2;
    }
    message Response {
        int64 provider_cache_handle = 1;
    }
}

message CloseProviderPluginCache {
    message Request {
        int64 provider_cache_handle = 1;
    }
    message Response {
    }
}

message GetCachedProviders {
    message Request {
        int64 provider_cache_handle = 1;
    }
    message Response {
        repeated ProviderPackage available_providers = 1;
    }
}

message GetProviderSchema {
    message Request {
        // The address of the provider to retrieve schema for, using the
        // typical provider source address syntax.
        //
        // When requesting schema based on a ProviderPackage message, populate
        // this with its "source_addr" field.
        string provider_addr = 1;
        // The version number of the given provider to retrieve the schema
        // of, which must have already been populated into the cache directory.
        //
        // Not supported for built-in providers because we can only access the
        // single "version" of the provider that's compiled into this Terraform
        // Core server, and so must be left unset or empty for those.
        //
        // When requesting schema based on a ProviderPackage message, populate
        // this with its "version" field.
        string provider_version = 2;

        // The handle for the previously-opened provider plugin cache to
        // load the provider plugin from.
        //
        // Optional for built-in providers, but can still be specified in that
        // case if desired so that callers can safely just send the handle they
        // have in all cases and be naive about which providers are and are
        // not built in.
        int64 provider_cache_handle = 3;
    }
    message Response {
        ProviderSchema schema = 1;
    }
}

// Represents a selected or available version of a provider, from either a
// dependency lock object (selected) or a provider cache object (available).
//
// This message type corresponds in meaning with a single "provider" block in a
// dependency lock file, but not all messages of this type directly represent
// such a physical block.
message ProviderPackage {
    // The address of the provider using the canonical form of the provider
    // source address syntax.
    string source_addr = 1;

    // The version number of this provider package. Unset for (and only for)
    // built-in providers; callers may use the set-ness of this field to
    // distinguish installable vs. built-in providers without having to
    // parse the source address syntax.
    string version = 2;

    // The hash strings that Terraform knows about for this provider package,
    // using the same "scheme:hash" syntax used in Terraform's dependency
    // lock file format.
    //
    // For a message representing a "selected" provider package this enumerates
    // all of the checksums that were previously loaded from a dependency
    // lock file or otherwise inserted into a dependency locks object, which
    // are usually (but not necessarily) originally obtained from the
    // provider's origin registry and then cached in the lock file.
    //
    // For a message representing an "available" provider package this
    // describes only the actual package on disk, and so will typically
    // include only the subset of the checksums from the corresponding
    // "selected" package that are relevant to the current platform where
    // Terraform Core is running.
    repeated string hashes = 3;
}

// ProviderSchema describes the full schema for a particular provider.
message ProviderSchema {
    Schema provider_config = 1;
    map<string, Schema> managed_resource_types = 2;
    map<string, Schema> data_resource_types = 3;
}

service Stacks {
    // Load and perform initial static validation of a stack configuration
    // in a previously-opened source bundle. If successful, returns a
    // stack configuration handle that can be used with other operations.
    rpc OpenStackConfiguration(OpenStackConfiguration.Request)
        returns (OpenStackConfiguration.Response);
    // Close a previously-opened stack configuration using its handle.
    rpc CloseStackConfiguration(CloseStackConfiguration.Request)
        returns (CloseStackConfiguration.Response);
    // Analyze a stack configuration to find all of the providers that it
    // depends on.
    rpc FindStackConfigurationProviders(FindStackConfigurationProviders.Request) 
        returns (FindStackConfigurationProviders.Response);
    // Analyze a stack configuration to find all of the components it declares.
    // This is static analysis only, so it cannot produce dynamic information
    // such as the number of instances of each component.
    rpc FindStackConfigurationComponents(FindStackConfigurationComponents.Request)
        returns (FindStackConfigurationComponents.Response);
    // Calculate a desired state from the given configuration and compare it
    // with the current state to propose a set of changes to converge the
    // current state with the desired state, at least in part.
    rpc PlanStackChanges(PlanStackChanges.Request)
        returns (stream PlanStackChanges.Event);
}

message OpenStackConfiguration {
    message Request {
        int64 source_bundle_handle = 1;
        SourceAddress source_address = 2;
    }
    message Response {
        int64 stack_config_handle = 1;
        repeated Diagnostic diagnostics = 2;
    }
}

message CloseStackConfiguration {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
    }
}

message FindStackConfigurationComponents {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
        StackConfig config = 1;
    }

    enum Instances {
        SINGLE = 0;
        COUNT = 1;
        FOR_EACH = 2;
    }
    message StackConfig {
        map<string, Component> components = 1;
        map<string, EmbeddedStack> embedded_stacks = 2;
    }
    message EmbeddedStack {
        string source_addr = 1;
        Instances instances = 2;
        StackConfig config = 3;
    }
    message Component {
        string source_addr = 1;
        Instances instances = 2;
    }
}

message FindStackConfigurationProviders {
    message Request {
        int64 stack_config_handle = 1;
    }
    message Response {
        // TODO
    }
}

message PlanStackChanges {
    message Request {
        PlanMode plan_mode = 1;
        int64 stack_config_handle = 2;
        map<string, google.protobuf.Any> previous_state = 3;
        // TODO: Various other planning options and dependencies such as a
        // provider cache handle.
    }
    message Event {
        oneof event {
            PlannedChange planned_change = 1;
            Diagnostic diagnostic = 2;
            // TODO
        }
    }
}

// Represents dynamically-typed data from within the Terraform language.
// Typically only one of the available serialization formats will be populated,
// depending on what serializations are appropriate for a particular context
// and what capabilities the client and the server negotiated during Handshake.
message DynamicValue {
    bytes msgpack = 1; // The default serialization format
    repeated AttributePath sensitive = 2; // Paths to any sensitive-marked values.
}

// Represents a change of some object from one  dynamic value to another.
message DynamicValueChange {
    DynamicValue old = 1;
    DynamicValue new = 2;
}

message AttributePath {
    message Step {
        oneof selector {
            // Set "attribute_name" to represent looking up an attribute
            // in the current object value.
            string attribute_name = 1;
            // Set "element_key_*" to represent looking up an element in
            // an indexable collection type.
            string element_key_string = 2;
            int64 element_key_int = 3;
        }
    }
    repeated Step steps = 1;
}

// Represents the address of a specific resource instance inside a specific
// component instance within the containing stack.
message ResourceInstanceInStackAddr {
    // Unique address of the component instance that this resource instance
    // belongs to. This is comparable with
    string component_instance_addr = 1;
    // Unique address of the resource instance within the given component
    // instance. Each component instance has a separate namespace of
    // resource instance addresses, so callers must take both fields together
    // to produce a key that's unique throughout the entire plan.
    string resource_instance_addr = 2;
}

// A source address in the same form as it would appear in a Terraform
// configuration: a source string combined with an optional version constraint
// string, where the latter is valid only for registry module addresses.
//
// This is not used for "final" source addresses that have already been reduced
// to an exact version selection. For those we just directly encode the string
// representation of the final address, including a version number if necessary.
message SourceAddress {
    string source = 1;
    string versions = 2;
}

enum PlanMode {
    NORMAL = 0;
    REFRESH_ONLY = 1;
    DESTROY = 2;
}

enum ChangeType {
    NOOP = 0;
    READ = 1;
    CREATE = 2;
    UPDATE = 3;
    DELETE = 4;
}

// Describes one item in a stack plan. The overall plan is the concatentation
// of all messages of this type emitted as events during the plan; splitting
// this information over multiple messages just allows the individual events
// to double as progress notifications for an interactive UI.
message PlannedChange {
    // Terraform Core's internal representation(s) of this change. Callers
    // must provide the messages in this field, if any, verbatim to the
    // ApplyStackChanges RPC in order to apply this change, and must not
    // attempt to decode or analyze the contents because they are subject
    // to change in future versions of Terraform Core.
    //
    // This might be unpopulated if this message represents only information
    // for the caller and Terraform Core doesn't actually need to recall this
    // information during the apply step. Callers must append each raw item
    // to the raw plan in the order specified, and provide them all together
    // in the same order to ApplyStackChanges.
    repeated google.protobuf.Any raw = 1;

    // Caller-facing description of this change, to use for presenting
    // information to end-users in the UI and for other subsystems such as
    // imposing policy rules on the resulting plan.
    //
    // If none of these fields are populated in a given event then the
    // raw messages in "raw" represent private information that has no
    // external-facing equivalent. Callers must still retain the raw messages
    // to provide to a subsequent ApplyStackChanges RPC.
    //
    // DO NOT attempt to use this to surgically filter particular changes
    // from a larger plan. Although external descriptions often match with
    // the raw representations in field "raw", that is not guaranteed and
    // Terraform Core assumes that it will always be provided with the full
    // set of raw messages -- in the same order they were emitted -- during
    // the apply step. For example, some raw messages might omit information
    // that is implied by earlier raw messages and would therefore be
    // incomplete if isolated.
    oneof description {
        ComponentInstance component_instance_planned = 2;
        ResourceInstance resource_instance_drifted = 3;
        ResourceInstance resource_instance_planned = 4;
        OutputValue output_value_planned = 5;
        bool plan_applyable = 6;
    }

    // A set of provider selections that will be needed to apply this
    // change, which the caller should remember and use to populate the
    // provider cache during the apply step.
    // TODO: Fill out all of the provider-related functionality in here.
    //repeated ProviderSelection providers = 6;

    // Reports the existence of a particular instance of a component,
    // once Terraform has resolved arguments such as "for_each" that
    // might make the set of instances dynamic.
    message ComponentInstance {
        // The address of the static component that this is an instance of.
        string component_addr = 1;
        // The address of the instance that's being announced. For
        // multi-instance components this could have any combination of
        // instance keys on the component itself or instance keys on any
        // of the containing embedded stacks.
        string component_instance_addr = 2;
        // The changes to the existence of this instance relative to the
        // prior state. This only considers the component instance directly,
        // and doesn't take into account what actions are planned for any
        // resource instances inside.
        repeated ChangeType actions = 3;
    }
    message ResourceInstance {
        ResourceInstanceInStackAddr addr = 1;
        repeated ChangeType actions = 2;
        DynamicValueChange values = 3;
        Moved moved = 4;
        Imported imported = 5;
        // TODO: Everything else we need for feature-parity with the
        // existing JSON plan export format.

        message Moved {
            ResourceInstanceInStackAddr prev_addr = 1;
        }
        message Imported {
            string import_id = 1;
        }
    }
    // Note: this is only for output values from the topmost
    // stack configuration, because all other output values are 
    // internal to the configuration and not part of its public API.
    message OutputValue {
        string name = 1;
        repeated ChangeType actions = 2;
        DynamicValueChange values = 3;
    }
}

message Diagnostic {
    enum Severity {
        INVALID = 0;
        ERROR = 1;
        WARNING = 2;
    }
    Severity severity = 1;
    string summary = 2;
    string detail = 3;
    SourceRange subject = 4;
    SourceRange context = 5;
}

message SourceRange {
    string source_addr = 1;
    SourcePos start = 2;
    SourcePos end = 3;
}

message SourcePos {
    int64 byte = 1;
    int64 line = 2;
    int64 column = 3;
}

// Schema describes a schema for an instance of a particular object, such as
// a resource type or a provider's overall configuration.
message Schema {
    // Block is the top level configuration block for this schema.
    Block block = 1;

    message Block {
        int64 version = 1;
        repeated Attribute attributes = 2;
        repeated NestedBlock block_types = 3;
        DocString description = 4;
        bool deprecated = 5;
    }

    message Attribute {
        string name = 1;
        bytes type = 2;
        Object nested_type = 10;
        DocString description = 3;
        bool required = 4;
        bool optional = 5;
        bool computed = 6;
        bool sensitive = 7;
        bool deprecated = 8;
    }

    message NestedBlock {
        enum NestingMode {
            INVALID = 0;
            SINGLE = 1;
            LIST = 2;
            SET = 3;
            MAP = 4;
            GROUP = 5;
        }

        string type_name = 1;
        Block block = 2;
        NestingMode nesting = 3;
        int64 min_items = 4;
        int64 max_items = 5;
    }

    message Object {
        enum NestingMode {
            INVALID = 0;
            SINGLE = 1;
            LIST = 2;
            SET = 3;
            MAP = 4;
        }

        repeated Attribute attributes = 1;
        NestingMode nesting = 3;
    }

    message DocString {
        string description = 1;
        Format format = 2;

        enum Format {
            PLAIN = 0;
            MARKDOWN = 1;
        }
    }
}
