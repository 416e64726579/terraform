package stackruntime

import (
	"context"
	"testing"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"go.opentelemetry.io/otel/trace/embedded"
)

// tracesToTestLog arranges for any traces generated by the current test to
// be emitted directly into the test log using the log methods of the given
// [testing.T].
//
// This works by temporarily reassigning the global tracer provider and so
// is not suitable for parallel tests or subtests of tests that have already
// called this function.
func tracesToTestLog(t *testing.T) {
	t.Helper()
	oldProvider := otel.GetTracerProvider()
	if _, ok := oldProvider.(testLogTracerProvider); ok {
		// This suggests that someone's tried to use tracesToTestLog in
		// a parallel test or in a subtest of a test that already called it.
		t.Fatal("overlapping tracesToTestLog")
	}

	provider := testLogTracerProvider{t: t}
	otel.SetTracerProvider(provider)

	t.Cleanup(func() {
		otel.SetTracerProvider(oldProvider)
	})
}

type testLogTracerProvider struct {
	t *testing.T

	embedded.TracerProvider
}

var _ trace.TracerProvider = testLogTracerProvider{}

// Tracer implements trace.TracerProvider.
func (p testLogTracerProvider) Tracer(name string, options ...trace.TracerOption) trace.Tracer {
	p.t.Helper()
	return testLogTracer{t: p.t}
}

type testLogTracer struct {
	t *testing.T

	embedded.Tracer
}

var _ trace.Tracer = testLogTracer{}

// Start implements trace.Tracer.
func (t testLogTracer) Start(ctx context.Context, spanName string, opts ...trace.SpanStartOption) (context.Context, trace.Span) {
	t.t.Helper()
	span := testLogTraceSpan{name: spanName, t: t.t}
	ctx = trace.ContextWithSpan(ctx, span)
	t.t.Logf("[trace] %s: START", span.name)
	return ctx, span
}

type testLogTraceSpan struct {
	name string
	t    *testing.T

	embedded.Span
}

var _ trace.Span = testLogTraceSpan{}

// AddEvent implements trace.Span.
func (s testLogTraceSpan) AddEvent(name string, options ...trace.EventOption) {
	s.t.Helper()
	s.t.Logf("[trace] %s: EVENT %s", s.name, name)
}

// End implements trace.Span.
func (s testLogTraceSpan) End(options ...trace.SpanEndOption) {
	s.t.Helper()
	s.t.Logf("[trace] %s: END", s.name)
}

// IsRecording implements trace.Span.
func (s testLogTraceSpan) IsRecording() bool {
	s.t.Helper()
	return true
}

// RecordError implements trace.Span.
func (s testLogTraceSpan) RecordError(err error, options ...trace.EventOption) {
	s.t.Helper()
	s.t.Logf("[trace] %s: ERROR %s", s.name, err)
}

// SetAttributes implements trace.Span.
func (s testLogTraceSpan) SetAttributes(kv ...attribute.KeyValue) {
	s.t.Helper()
}

// SetName implements trace.Span.
func (s testLogTraceSpan) SetName(name string) {
	s.t.Helper()
	s.t.Logf("[trace] %s: RENAMED to %s", s.name, name)
	s.name = name
}

// SetStatus implements trace.Span.
func (s testLogTraceSpan) SetStatus(code codes.Code, description string) {
	s.t.Helper()
	s.t.Logf("[trace] %s: STATUS %s: %s", s.name, code, description)
}

// SpanContext implements trace.Span.
func (s testLogTraceSpan) SpanContext() trace.SpanContext {
	s.t.Helper()
	return trace.SpanContext{
		// intentionally invalid, since we're not actually keeping track
		// of anything persistently.
	}
}

// TracerProvider implements trace.Span.
func (s testLogTraceSpan) TracerProvider() trace.TracerProvider {
	s.t.Helper()
	return testLogTracerProvider{t: s.t}
}
